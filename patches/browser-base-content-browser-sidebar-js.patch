diff --git a/browser/base/content/browser-sidebar.js b/browser/base/content/browser-sidebar.js
index 88f7ed1afbb0f25130ae9b2c6d5058da1fc3a21e..22ab7ba977fa811b8d40e18a15948abf0785d7e0 100644
--- a/browser/base/content/browser-sidebar.js
+++ b/browser/base/content/browser-sidebar.js
@@ -17,7 +17,7 @@ var SidebarUI = {
           title: document
             .getElementById("sidebar-switcher-bookmarks")
             .getAttribute("label"),
-          url: "chrome://browser/content/places/bookmarksSidebar.xhtml",
+          url: "chrome://browser/content/sidebars/bookmarks/sidebar.html",
           menuId: "menu_bookmarksSidebar",
         },
       ],
@@ -42,6 +42,16 @@ var SidebarUI = {
           menuId: "menu_tabsSidebar",
         },
       ],
+      [
+        "viewAccountsSidebar",
+        {
+          title: document.getElementById("sidebar-switcher-accounts")
+            .getAttribute("label"),
+          url: "about:profiles",
+          menuId: "menu_accountsSidebar",
+          buttonId: "sidebar-switcher-accounts"
+        },
+      ],
     ]));
   },
 
@@ -61,6 +71,7 @@ var SidebarUI = {
   lastOpenedId: null,
 
   _box: null,
+  _iconBar: null,
   // The constructor of this label accesses the browser element due to the
   // control="sidebar" attribute, so avoid getting this label during startup.
   get _title() {
@@ -89,6 +100,7 @@ var SidebarUI = {
 
   init() {
     this._box = document.getElementById("sidebar-box");
+    this._iconBar = document.getElementById("sidebar-iconbar");
     this._splitter = document.getElementById("sidebar-splitter");
     this._icon = document.getElementById("sidebar-icon");
     this._reversePositionButton = document.getElementById(
@@ -281,10 +293,16 @@ var SidebarUI = {
       return true;
     }
 
+    console.log(sourceUI._box, sourceUI._box.getBoundingClientRect().width)
+
     this._box.setAttribute(
       "width",
       sourceUI._box.getBoundingClientRect().width
     );
+    this._box.setAttribute(
+      "--sidebar-width",
+      sourceUI._box.getBoundingClientRect().width
+    );
     this.showInitially(commandID);
 
     return true;
@@ -451,11 +469,15 @@ var SidebarUI = {
     return this._show(commandID).then(() => {
       this._loadSidebarExtension(commandID);
 
+      this.ensureTooltipSet();
+
       if (triggerNode) {
         updateToggleControlLabel(triggerNode);
       }
 
       this._fireFocusedEvent();
+
+      this._box.style.marginLeft = ``;
       return true;
     });
   },
@@ -494,7 +516,13 @@ var SidebarUI = {
     return new Promise(resolve => {
       this.selectMenuItem(commandID);
 
+      let { url, title } = this.sidebars.get(commandID);
+      this.title = title;
+      this.browser.style.backgroundColor = "var(--sidebar-background-color)";
+      this.browser.setAttribute("src", url); // kick off async load
+
       this._box.hidden = this._splitter.hidden = false;
+      this._iconBar.hidden = this._splitter.hidden = false;
       this.setPosition();
 
       this.hideSwitcherPanel();
@@ -503,10 +531,6 @@ var SidebarUI = {
       this._box.setAttribute("sidebarcommand", commandID);
       this.lastOpenedId = commandID;
 
-      let { url, title } = this.sidebars.get(commandID);
-      this.title = title;
-      this.browser.setAttribute("src", url); // kick off async load
-
       if (this.browser.contentDocument.location.href != url) {
         this.browser.addEventListener(
           "load",
@@ -546,17 +570,26 @@ var SidebarUI = {
 
     this.selectMenuItem("");
 
+    this._box.removeAttribute("checked");
+
+    this._box.style.marginLeft = `${-Math.abs(this._box.getBoundingClientRect().width)}px`
+
+    let animationsDisabled = Services.prefs.getBoolPref("sidebar.animations.disabled");
+
+    setTimeout(() => {
+      this._box.hidden = this._splitter.hidden = true;
+      this._iconBar.hidden = this._splitter.hidden = true;
+    }, animationsDisabled ? 0 : 170);
+
     // Replace the document currently displayed in the sidebar with about:blank
     // so that we can free memory by unloading the page. We need to explicitly
     // create a new content viewer because the old one doesn't get destroyed
     // until about:blank has loaded (which does not happen as long as the
     // element is hidden).
+    this.browser.style.backgroundColor = "var(--sidebar-background-color)";
     this.browser.setAttribute("src", "about:blank");
     this.browser.docShell.createAboutBlankContentViewer(null, null);
 
-    this._box.removeAttribute("checked");
-    this._box.hidden = this._splitter.hidden = true;
-
     let selBrowser = gBrowser.selectedBrowser;
     selBrowser.focus();
     if (triggerNode) {
@@ -588,6 +621,15 @@ var SidebarUI = {
       }
     }
   },
+
+  ensureTooltipSet() {
+    for (let [id, { title, buttonId }] of this.sidebars) {
+      let button = document.getElementById(buttonId);
+
+      button.setAttribute("tooltiptext", title);
+      button.setAttribute("context", "sidebar-item-context-menu");
+    };
+  }
 };
 
 // Add getters related to the position here, since we will want them
